## Introduction

I was a member of a six-member team that developed this compiler from scratch for the Compiler Construction course offered at BITS. The language supports macros, types, control flow, and functions. We have also implemented optimizations such as Constant Folding and Branch Elimination. A more detailed specification can be found [here](https://drive.google.com/file/d/1mjeCqbuMLnDRFHUekJsRVyr6mqvnDZXk/view?usp=sharing).  

We used the following technologies and tools:
- **Flex**: Used for lexical analysis to tokenize the source code.
- **Bison**: Utilized for syntax analysis and generating the abstract syntax tree (AST).
- **LLVM**: Employed as the backend for code generation.

## Installing requirements

This compiler requires a *NIX environment. One can run these commands to install all the software needed to compile this project properly:

For Linux

```bash
# the tool used to build this project
sudo apt-get install make
# the tool used for lexing/scanning
sudo apt-get install flex
# the tool used for parsing
sudo apt-get install bison
# the LLVM toolchain
sudo apt-get install clang llvm
```
For MacOS (Unix)

```bash
# install Homebrew if you haven't already
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
# the tool used to build this project
make install
# the tool used for lexing/scanning
brew install flex
# the tool used for parsing
brew install bison
export PATH="$(brew --prefix bison)/bin:$PATH"
# the LLVM toolchain
echo 'export PATH="/usr/local/opt/llvm/bin:$PATH"' >> ~/.bash_profile
source ~/.bash_profile
```

## Running this project

To build the compiler, one can simply run `make compiler`. The executable will be in the `bin` folder. This is the compiler.

To run this compiler, one can simply run `make program`. This would use the [`test.be`](test.be) file and generate an executable of that program called `bin/test`. This binary is dependent on the [`runtime/runtime_lib.cc`](runtime/runtime_lib.cc) file so make sure it exists.

## Directory structure

```
CSF363-baseline
├── include
│   ├── ast.hh
│   ├── llvmcodegen.hh
│   ├── parser_util.hh
│   └── symbol.hh
├── Makefile
├── README.md
├── runtime
│   └── runtime_lib.cc
├── src
│   ├── ast.cc
│   ├── lexer.lex
│   ├── llvmcodegen.cc
│   ├── main.cc
│   ├── parser.yy
│   └── symbol.cc
└── test.be
│  
└── docs
    ├── lexer.md
    ├── parser.md
    └── llvm.md
```

- The bin folder contains the executable after running `make`
- The [`include`](include) folder contains all header files. 
    - [`include/ast.hh`](include/ast.hh) contains the definition of the the AST of this language. We have defined one parent class `Node` as a pure abstract class (similiar to an interface in Java). All types of nodes inherit from this one `Node` class. By following the definition of the various node types, the tree structure of these ndoes becomes clearer.
    - [`include/llvmcodegen.hh`](include/llvmcodegen.hh) contains the definition of the compiler which emits LLVM-IR code.
    - [`include/parser_util.hh`](include/parser_util.hh) contains the definition of a struct to help bison parse. 
    - [`symbol.hh`](symbol.hh) contains the definition of rudimentary symbol table.
- The [`src`](src) folder contains the implementation files for the header files. 
    - [`src/lexer.lex`](src/lexer.lex) contains the specification of the scanner. Each token's regex has a subsequent action. In this file, the action is to return the corresponding token that is defined in `src/parser.yy` at lines 28-31. This file uses the flex lexer generator tool.
    - [`src/parser.yy`](src/parser.yy) contains the specification of the parser and the overall grammar of the language. This parser builds an AST as defined in [`include/ast.hh`](include/ast.hh). This files uses the bison parser generator tool.
    - [`src/main.cc`](src/main.cc) is the main driver file.

  

>`include/parser.hh` is header file that you may think is missing, but it is actually generated by bison with `src/bison.yy` as input. You should see it in [`include`](include) after running `make` once.

## Example

```
fun factorial(n : long) : long {
    if n {
        ret factorial(n - 1) * n;
    } 
    else {
        ret 1;
    }
}
fun main(): int {
    let n : int = 20;
    let res : long = factorial(n);
    dbg res;
}
```



